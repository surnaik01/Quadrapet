<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Face States Demo — Blue Eyes</title>
    <style>
        :root {
            /* color system (tweak to taste) */
            --ring-dark: #2a2f36;
            --iris-blue: #19a2e6;
            /* main blue ring */
            --iris-blue-2: #2ec4ff;
            /* lighter ring + smile */
            --iris-core: #0b1727;
            /* inner dark */
            --pupil: #060d13;

            --iris-h: 200;
            /* used for minor saturation shifts */
            --iris-s: 90;
            --iris-l: 52;

            --gaze-x: 0px;
            /* pupil offset */
            --gaze-y: 0px;
            --glow-alpha: .18;
            /* halo opacity */
            --dim: 1;
            /* global dimmer for muted */
        }

        body {
            background: #0a0a0a;
            color: #d7e7ff;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            display: grid;
            place-items: center;
            min-height: 100vh;
            gap: 18px;
        }

        .shell {
            width: min(980px, 94vw);
            display: grid;
            gap: 14px;
        }

        .stage {
            position: relative;
            background: #000;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, .6), inset 0 0 40px rgba(0, 120, 255, .08);
            padding: 24px;
        }

        .row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            justify-content: center;
        }

        button {
            background: #0e1b2b;
            border: 1px solid #1f3557;
            color: #d7e7ff;
            padding: 8px 12px;
            border-radius: 12px;
            font-weight: 600;
            letter-spacing: .2px;
            cursor: pointer;
            transition: .2s ease;
        }

        button:hover {
            transform: translateY(-1px);
            background: #12233a;
        }

        .badge {
            opacity: .9;
            font-size: .9rem;
            padding: .25rem .5rem;
            border-radius: 8px;
            background: #142133;
            border: 1px solid #213756;
        }

        svg {
            display: block;
            width: 100%;
            height: auto;
            filter: saturate(var(--dim));
        }

        /* States */
        .stage[data-state="idle"] {
            --iris-s: 90;
            --glow-alpha: .12;
        }

        .stage[data-state="listening"] {
            --iris-s: 98;
            --glow-alpha: .20;
        }

        .stage[data-state="thinking"] {
            --iris-s: 65;
            --glow-alpha: 0;
        }

        .stage[data-state="speaking"] {
            --iris-s: 100;
            --glow-alpha: .32;
        }

        .stage[data-state="muted"] {
            --iris-s: 0;
            --glow-alpha: 0;
            --dim: .7;
            filter: grayscale(.2) brightness(.85);
        }

        /* Halos */
        .halo {
            opacity: var(--glow-alpha);
            transform-origin: center;
        }

        .stage[data-state="idle"] .halo {
            animation: breathe 7s ease-in-out infinite;
        }

        .stage[data-state="listening"] .halo {
            animation: pulse 900ms ease-in-out infinite;
        }

        .stage[data-state="speaking"] .halo {
            animation: throb 320ms ease-in-out infinite;
        }

        @keyframes breathe {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.02);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.07);
            }
        }

        @keyframes throb {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.06);
            }
        }

        /* Gaze */
        .pupil,
        .glints {
            transform: translate(var(--gaze-x), var(--gaze-y));
        }

        /* Eyelids — positioned fully open; used only for blinks */
        .lidTop {
            transform: translateY(0);
        }

        .lidBot {
            transform: translateY(0);
        }

        /* One-shot blink */
        .blink .lidTop,
        .blink .lidBot {
            animation: blinkOnce 230ms cubic-bezier(.3, .7, .2, 1) 1;
        }

        @keyframes blinkOnce {
            0% {
                transform: translateY(0);
            }

            45% {
                transform: translateY(140px);
            }

            55% {
                transform: translateY(140px);
            }

            100% {
                transform: translateY(0);
            }
        }

        /* Listening ping */
        .ping .ripple {
            animation: ripple 700ms ease-out 1;
        }

        @keyframes ripple {
            0% {
                transform: scale(.2);
                opacity: .35;
            }

            100% {
                transform: scale(1.6);
                opacity: 0;
            }
        }

        /* Thinking dots */
        .dots {
            opacity: 0;
        }

        .stage[data-state="thinking"] .dots {
            opacity: 1;
        }

        .stage[data-state="thinking"] .dots circle {
            animation: dot 900ms ease-in-out infinite;
        }

        .stage[data-state="thinking"] .dots circle:nth-child(2) {
            animation-delay: .12s;
        }

        .stage[data-state="thinking"] .dots circle:nth-child(3) {
            animation-delay: .24s;
        }

        @keyframes dot {

            0%,
            100% {
                opacity: .25;
                transform: translateY(0);
            }

            50% {
                opacity: 1;
                transform: translateY(-5px);
            }
        }

        /* Equalizer */
        .eq {
            opacity: 0;
            transform-origin: 50% 100%;
        }

        .stage[data-state="speaking"] .eq {
            opacity: 1;
        }

        .eq rect {
            transform-origin: 50% 100%;
        }

        @media (prefers-reduced-motion: reduce) {

            .halo,
            .dots circle {
                animation: none !important;
            }
        }
    </style>
</head>

<body>
    <div class="shell">
        <div class="row" role="group" aria-label="State">
            <button data-go="idle">Idle</button>
            <button data-go="listening">Listening</button>
            <button data-go="thinking">Thinking</button>
            <button data-go="speaking">Speaking</button>
            <button data-go="muted">Muted</button>
            <span class="badge">State: <strong id="stateLabel">idle</strong></span>
        </div>

        <div class="row" role="group" aria-label="Play">
            <button id="btnBlink">Blink once</button>
            <button id="btnPing">Listening ping</button>
            <button id="btnSpeakDemo">Speak demo (2s)</button>
        </div>

        <div id="stage" class="stage" data-state="idle" aria-live="polite" data-svg-source="eyes.svg">
            <!-- SVG will be loaded here by JavaScript -->
        </div>

        <small style="opacity:.75; text-align:center;">
            Tip: Move your mouse across the stage while in <strong>Listening</strong> to see subtle gaze tracking.
        </small>
    </div>

    <script>
        (() => {
            // Load external SVG content
            async function loadSVG() {
                const stage = document.getElementById('stage');
                const svgSource = stage.getAttribute('data-svg-source');
                
                try {
                    const response = await fetch(svgSource);
                    const svgText = await response.text();
                    stage.innerHTML = svgText;
                } catch (error) {
                    console.error('Failed to load SVG:', error);
                    // Fallback to basic structure if external SVG fails
                    stage.innerHTML = `
                        <svg viewBox="0 0 900 420" aria-hidden="true">
                            <text x="450" y="210" text-anchor="middle" fill="white">SVG Loading Failed</text>
                        </svg>
                    `;
                }
            }
            
            // Initialize SVG loading
            loadSVG().then(() => {
                // Initialize animations after SVG is loaded
                initializeAnimations();
            });
            
            function initializeAnimations() {
                const stage = document.getElementById('stage');
                const stateLabel = document.getElementById('stateLabel');
                const eq = document.getElementById('eq');
                const buttons = [...document.querySelectorAll('button[data-go]')];
                const btnBlink = document.getElementById('btnBlink');
                const btnPing = document.getElementById('btnPing');
                const btnSpeakDemo = document.getElementById('btnSpeakDemo');

            let state = 'idle';
            let rafThinking = null;
            let rafSpeaking = null;
            let speakingDemoTimer = null;
            let blinkTimer = null;

            function setState(next) {
                if (state === next) return;
                state = next;
                stage.setAttribute('data-state', state);
                stateLabel.textContent = state;

                stopThinking();
                stopSpeaking();

                if (state === 'thinking') startThinking();
                if (state === 'speaking') startSpeaking();

                scheduleIdleBlink();
                setGaze(0, 0);
                stage.classList.remove('blink', 'ping');
            }
            buttons.forEach(b => b.addEventListener('click', () => setState(b.dataset.go)));

            /* GAZE: mouse-follow in Listening */
            function setGaze(x, y) {
                stage.style.setProperty('--gaze-x', x + 'px');
                stage.style.setProperty('--gaze-y', y + 'px');
            }
            stage.addEventListener('mousemove', (e) => {
                if (state !== 'listening') return;
                const rect = stage.getBoundingClientRect();
                const nx = (e.clientX - rect.left) / rect.width;
                const ny = (e.clientY - rect.top) / rect.height;
                const amp = 14;
                setGaze((nx - .5) * amp * 2, (ny - .5) * amp * 1.6);
            });

            /* THINKING drift */
            function startThinking() {
                let t0 = performance.now();
                const step = (t) => {
                    const dt = (t - t0) / 1000;
                    const x = Math.sin(dt * 2.1) * 9;
                    const y = Math.sin(dt * 4.2) * 5;
                    setGaze(x, y);
                    rafThinking = requestAnimationFrame(step);
                };
                rafThinking = requestAnimationFrame(step);
            }
            function stopThinking() { if (rafThinking) { cancelAnimationFrame(rafThinking); rafThinking = null; } }

            /* SPEAKING equalizer + brow bounce */
            const eqBars = [...eq.querySelectorAll('rect')];
            const brows = [...document.querySelectorAll('.brow')];

            function startSpeaking() {
                const step = () => {
                    const energy = Math.pow(Math.random(), 2);
                    eqBars.forEach((bar, i) => {
                        const jitter = Math.max(0.08, energy + (Math.random() - .5) * 0.15);
                        const h = 100 * jitter * (1 + (i === 2 ? 0.35 : 0));
                        bar.setAttribute('height', h.toFixed(1));
                        bar.setAttribute('y', -h.toFixed(1));
                    });
                    const browY = -2 - 4 * energy;
                    brows.forEach(b => b.setAttribute('transform', `translate(0, ${browY.toFixed(2)})`));
                    rafSpeaking = requestAnimationFrame(step);
                };
                rafSpeaking = requestAnimationFrame(step);
            }
            function stopSpeaking() {
                if (rafSpeaking) { cancelAnimationFrame(rafSpeaking); rafSpeaking = null; }
                eqBars.forEach(b => { b.setAttribute('height', 0); b.setAttribute('y', 0); });
                brows.forEach(b => b.removeAttribute('transform'));
            }

            /* One-shots */
            document.getElementById('btnBlink').addEventListener('click', () => {
                stage.classList.remove('blink'); void stage.offsetWidth;
                stage.classList.add('blink');
                setTimeout(() => stage.classList.remove('blink'), 260);
            });
            document.getElementById('btnPing').addEventListener('click', () => {
                stage.classList.remove('ping'); void stage.offsetWidth;
                stage.classList.add('ping');
                setTimeout(() => stage.classList.remove('ping'), 750);
            });
            document.getElementById('btnSpeakDemo').addEventListener('click', () => {
                const prior = state;
                setState('speaking');
                clearTimeout(speakingDemoTimer);
                speakingDemoTimer = setTimeout(() => setState(prior === 'speaking' ? 'idle' : prior), 2000);
            });

            /* Idle random blinks */
            function scheduleIdleBlink() {
                clearTimeout(blinkTimer);
                if (state !== 'idle') return;
                const wait = 1800 + Math.random() * 4200;
                blinkTimer = setTimeout(() => { document.getElementById('btnBlink').click(); scheduleIdleBlink(); }, wait);
            }
                scheduleIdleBlink();
                setState('idle');
            } // end initializeAnimations
        })();
    </script>
</body>

</html>